#@ File	(label = "Input image directory", style = "directory") srcFile
#@ File	(label = "Input ROIset directory", style = "directory") roiFile
#@ File	(label = "Output directory", style = "directory") dstFile
#@ String  (label = "Image file extension", value=".nd2") ext
#@ String  (label = "Image file name contains", value = "") containString
#@ boolean (label = "Keep directory structure when saving", value = true) keepDirectories

# Find aggregates in two channels using a Difference of Gaussians detector
# Find aggregates "co-localizing" within a user-determined distance criterion
# Uses a saved ROI set to collect per-cell data including aggregate count, cell and cytoplasm area
# Limitations: Each image must have an ROI set
# 
# ------- ROISet FORMAT ----------
# ROI filename MUST BE imagename_RoiSet_Cyto_Rois.zip
# 1st ROI = background measurement (ignored here)
# 2nd and 3rd, 4th and 5th, etc.: nucleus (Nucl_1) and whole cell (Cell_1), respectively, for cell # 1, 2, etc.
# Last ROIs: Cyto_1, etc. for cytoplasm (cell minus nucleus) of each cell
# The cytoplasm ROIs can be generated by the Cytoplasm_ROI.py script 

# Based on https://github.com/bioimage-analysis/find_close_peaks by Cedric Espenel, Stanford University
# updated by Theresa Swayne, Columbia University, 2022, 2024, 2025
# Saves results, log, and ROI manager point selections

#  -------- Suggested text for acknowledgement -----------
#   "These studies used the Confocal and Specialized Microscopy Shared Resource 
#   of the Herbert Irving Comprehensive Cancer Center at Columbia University, 
#   funded in part through the NIH/NCI Cancer Center Support Grant P30CA013696."

from ij import IJ, ImagePlus, ImageStack
from ij.plugin import ZProjector
from ij.plugin.filter import RankFilters
from ij.plugin.filter import BackgroundSubtracter
import net.imagej.ops
from net.imglib2.view import Views
from net.imglib2.img.display.imagej import ImageJFunctions as IL
from net.imglib2.algorithm.dog import DogDetection
from ij.gui import Roi, PointRoi
from jarray import zeros
from ij.measure import ResultsTable
from math import sqrt
from java.awt import Color
from ij.plugin.frame import RoiManager
from ij.gui import GenericDialog
import os
from loci.plugins import BF


def distance(peak_1, peak_2):
	return sqrt((peak_2[1] - peak_1[1]) * (peak_2[1] - peak_1[1]) + (peak_2[0] - peak_1[0]) * (peak_2[0] - peak_1[0]))

def getOptions(): # in pixels
	gd = GenericDialog("Options")
	gd.addStringField("Name of first channel: ", "FUS");
	gd.addStringField("Name of second channel: ", "DNAJB6");

	gd.addNumericField("Channel number for first channel", 3, 0)
	gd.addNumericField("Channel number for second channel", 2, 0)

	#gd.addNumericField("radius_background", 100, 0)
 	gd.addNumericField("Min peak width (sigma) in calibrated units", 1, 2)
 	gd.addNumericField("Max peak width (sigma) in calibrated units", 5, 2)
  	gd.addNumericField("minPeakValue aggregate channel", 600, 0)
  	gd.addNumericField("minPeakValue second channel", 20, 0)
  	gd.addNumericField("Minimum distance in pixels", 2, 0) # TODO: Clarify pixel vs micron

  	gd.showDialog()
	ch1Name = gd.getNextString()
	ch2Name = gd.getNextString()

	Channel_1 = gd.getNextNumber()
	Channel_2 = gd.getNextNumber()

	#radius_background = gd.getNextNumber()
  	sigmaSmaller = gd.getNextNumber()
  	sigmaLarger = gd.getNextNumber()
  	minPeakValueCh1 = gd.getNextNumber()
	minPeakValueCh2 = gd.getNextNumber()
  	min_dist = gd.getNextNumber()
  	#return int(Channel_1), int(Channel_2), radius_background, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist
  	return ch1Name, ch2Name, int(Channel_1), int(Channel_2), sigmaSmaller, sigmaLarger, minPeakValueCh1,minPeakValueCh2, min_dist

def extract_channel(imp_max, ch1Name, ch2Name, Channel_1, Channel_2):

	# convert channel into floating-point ImageProcessor
	stack = imp_max.getImageStack()
	
	ch_1 = ImageStack(imp_max.width, imp_max.height)
	ch_1.addSlice(str(Channel_1), stack.getProcessor(Channel_1))
	ch1 = ImagePlus(ch1Name + str(Channel_1), ch_1)
	ch1_1 = ch1.duplicate()
	ip1 = ch1_1.getProcessor().convertToFloat()

	ch_2 = ImageStack(imp_max.width, imp_max.height)
	ch_2.addSlice(str(Channel_2), stack.getProcessor(Channel_2))
	ch2 = ImagePlus(ch2Name + str(Channel_2), ch_2)
	ch2_1 = ch2.duplicate()
	ip2 = ch2_1.getProcessor().convertToFloat()

	return ip1, ip2

def back_subtraction(ip1, radius_background):
	# Background subtraction to correct for large-scale background variation
	bgs=BackgroundSubtracter()
	bgs.rollingBallBackground(ip1, radius_background, False, False, True, True, True)

	imp1 = ImagePlus("ch1 back sub", ip1)

	return imp1

def find_peaks(imp1, imp2, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2):
	# FIND PEAKS
	# sigmaSmaller ==> Size of the smaller dots (in calibrated units)
	# sigmaLarger ==> Size of the bigger dots (in calibrated units)
	# minPeakValue ==> Intensity above which to look for dots
	
	# Preparation first channel
	ip1_1 = IL.wrapReal(imp1)
	ip1E = Views.extendMirrorSingle(ip1_1)
	imp1.show()

	#Preparation second channel
	ip2_1 = IL.wrapReal(imp2)
	ip2E = Views.extendMirrorSingle(ip2_1)
	imp2.show()
	
	# calibration = [1.0 for i in range(ip1_1.numDimensions())]
	cal = imp1.getCalibration()
	calibration = [cal.pixelWidth] # must be a double array 
	extremaType = DogDetection.ExtremaType.MINIMA
	normalizedMinPeakValue = False

	dog_1 = DogDetection(ip1E, ip1_1, calibration, sigmaSmaller, sigmaLarger,
	  				   extremaType, minPeakValueCh1, normalizedMinPeakValue)

	dog_2 = DogDetection(ip2E, ip2_1, calibration, sigmaSmaller, sigmaLarger,
	  				   extremaType, minPeakValueCh2, normalizedMinPeakValue)

	peaks_1 = dog_1.getPeaks()
	peaks_2 = dog_2.getPeaks()

	return ip1_1, ip2_1, peaks_1, peaks_2
	

def pointsInRoi(cellNumber, aggName, areaRoi, pointSet):
		# count points inside the cytoplasm, but avoid error if there are none
		# cellNumber: the ID of the cell within an image with multiple cells
		# aggName: the name of the channel or condition defining the pointSet
		# areaRoi: an ROI in the manager representing the area in which to detect points
		# pointSet: a point ROI representing the total points in the image
		# return: the number of points in the pointSet falling within the areaRoi, and a point ROI containing those points
		roiMgr = RoiManager.getInstance()
		try:
			aggsInCyto = pointSet.containedPoints(areaRoi)
			aggCount = aggsInCyto.getCount(0)
		except AttributeError, e1:
			IJ.log("There are no points inside ROI " + str(cellNumber))
			aggCount = 0
		else:
			IJ.log("Cytoplasm " + str(cellNumber) + " contains " + str(aggCount) + " puncta of " + aggName)
			roiMgr.addRoi(aggsInCyto)
			numRois = roiMgr.getCount()
			lastRoi = numRois-1
			roiMgr.select(lastRoi) # starts at 0
			roiMgr.rename(lastRoi, "Aggs_" + aggName + "_" + str(cellNumber))
			roiMgr.runCommand("Deselect")
			
		return aggsInCyto, aggCount

#def process(srcDir, dstDir, currentDir, fileName, keepDirectories, Channel_1, Channel_2, radius_background, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist):
def process(srcDir, roiDir, dstDir, currentDir, fileName, keepDirectories, ch1Name, ch2Name, Channel_1, Channel_2, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist):
 	IJ.run("Close All", "")

 	# Opening the image
 	IJ.log("Opening image " + fileName)
 	#imp = IJ.openImage(os.path.join(currentDir, fileName))
	#imp = IJ.getImage()
	imp = BF.openImagePlus(os.path.join(currentDir, fileName))
	imp = imp[0]

	IJ.log("Computing Max Intensity Projection")
	if imp.getDimensions()[3] > 1:
		imp_max = ZProjector.run(imp,"max")
	else:
		imp_max = imp

	ip1, ip2 = extract_channel(imp_max, ch1Name, ch2Name, Channel_1, Channel_2)

	#IJ.log("Subtracting background")
	#imp1 = back_subtraction(ip1, radius_background)
	imp1 = ImagePlus(ch1Name, ip1)
	imp2 = ImagePlus(ch2Name, ip2)

	IJ.log("Finding Peaks")
	#ip1_1, peaks_1 = find_peaks(imp1, sigmaSmaller, sigmaLarger, minPeakValueCh1)
	ip1_1, ip2_1, peaks_1, peaks_2 = find_peaks(imp1, imp2, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2)

	roi_1 = PointRoi() # 1st channel peaks
	roi_2 = PointRoi() # 2nd channel peaks
	roi_3 = PointRoi() # 2nd channel close to 1st Channel
	roi_4 = PointRoi() # 1st channel close to 2nd Channel

	# A temporary array of integers, one per dimension the image has
	p_1 = zeros(ip1_1.numDimensions(), 'i')
	p_2 = zeros(ip2_1.numDimensions(), 'i')

	# set up a table for coordinates
	peaksTable = ResultsTable()

	# Load every peak as a point in the PointRoi
	for peak in peaks_1:
		# Read peak coordinates into an array of integers
		peak.localize(p_1)
		roi_1.addPoint(imp1, p_1[0], p_1[1])
		# print("adding point " + str(p_1[0]) + "," + str(p_1[1]))
		peaksTable.incrementCounter()
		peaksTable.addValue("Channel",ch1Name)
		peaksTable.addValue("X",p_1[0])
		peaksTable.addValue("Y",p_1[1])

	for peak in peaks_2:
		# Read peak coordinates into an array of integers
		peak.localize(p_2)
		roi_2.addPoint(imp2, p_2[0], p_2[1])
		peaksTable.incrementCounter()
		peaksTable.addValue("Channel",ch2Name)
		peaksTable.addValue("X",p_2[0])
		peaksTable.addValue("Y",p_2[1])
	
	# Check for close peaks

	for peak_1 in peaks_1:
		peak_1.localize(p_1)
		for peak_2 in peaks_2:
			peak_2.localize(p_2)
			d1 = distance(p_1, p_2)
			if  d1 < min_dist:
				roi_3.addPoint(imp1, p_1[0], p_1[1]) # in ch2 and close to ch1
				break

	for peak_2 in peaks_2:
		peak_2.localize(p_2)
		for peak_1 in peaks_1:
			peak_1.localize(p_1)
			d2 = distance(p_2, p_1)
			if  d2 < min_dist:
				roi_4.addPoint(imp1, p_2[0], p_2[1]) # in ch1 and close to ch2
				break

	# load cell ROIs
	rm = RoiManager.getInstance()
	if not rm:
		rm = RoiManager()
	rm.reset()

	baseName = os.path.splitext(fileName)[0]	
	# strip off the -MaxIP
	roiName = baseName[:-6] + "_RoiSet_Cyto_Rois.zip"
	IJ.log("Opening ROI set " + roiName)
	rm.runCommand("Open", (os.path.join(roiDir, roiName)))

	# per-cell measurements
	# how many peaks are within each cytosol ROI
	
	# how many cells do we have?
	# assumptions: 1 background ROI, 3 ROIs per cell
	numRois = rm.getCount()
	numCells = (numRois - 1)/3
	if (numRois - 1) % 3 != 0:
		IJ.log("Skipped image " + fileName + " because it has an invalid number of ROIs.")
		return
	
	cellAreas = zeros(numCells, "d")
	cytoAreas = zeros(numCells, "d")
	#aggCounts = zeros(numCells, "i")
	
	# collect results in table
	# convert user-supplied distance in pixels to calibrated units for results 
	cal = imp.getCalibration()
	table = ResultsTable()
	
	# collect per-cell data
	for cell in range(0, numCells):
		
		cellNum = cell + 1
		ch1AggsInCyto = PointRoi()
		ch2AggsInCyto = PointRoi()
		ch2CloseToCh1 = PointRoi()
		ch1CloseToCh2 = PointRoi()
		
		# the first cell ROI is index 2.
		#cellRoiNum = cell * 2 + 2
		#cellRoi = rm.getRoi(cellRoiNum)
		#cellStat = cellRoi.getStatistics()
		#cellArea = cellStat.area
		#IJ.log("Cell " + str(cellNum) + " area= " + str(cellArea))
		
		# the first cytoplasm ROI is after the background and all of the cell + nucleus ROIs
		cytoRoiNum = numCells * 2 + cell + 1
		cytoRoi = rm.getRoi(cytoRoiNum)
		cytoStat = cytoRoi.getStatistics()
		cytoArea = cytoStat.area
		cytoName = cytoRoi.getName()
		ch2CloseToCh1Name = ch2Name + "_close_to_" + ch1Name
		ch1CloseToCh2Name = ch1Name + "_close_to_" + ch2Name

		ch1AggsInCyto, ch1Count = pointsInRoi(cellNum, ch1Name, cytoRoi, roi_1)
		ch2AggsInCyto, ch2Count = pointsInRoi(cellNum, ch2Name, cytoRoi, roi_2)
		ch2CloseToCh1, ch2CloseToCh1Count = pointsInRoi(cellNum, ch2CloseToCh1Name, cytoRoi, roi_3)
		ch1CloseToCh2, ch1CloseToCh2Count = pointsInRoi(cellNum, ch1CloseToCh2Name, cytoRoi, roi_4)
		
		table.incrementCounter()
		table.addValue("Cell ID", cellNum)
		table.addValue("Cytoplasm Area", cytoArea)
		table.addValue("%s Puncta in Cytoplasm" %(ch1Name), ch1Count)
		table.addValue("%s Puncta in Cytoplasm" %(ch2Name), ch2Count)
		table.addValue("%s within %s um of %s" %(ch2Name, min_dist, ch1Name), ch2CloseToCh1Count)
		table.addValue("%s within %s um of %s" %(ch1Name, min_dist, ch2Name), ch1CloseToCh2Count)

	rm.runCommand(imp1, "Show All")
	# Also show the image with the PointRoi on it:  
	imp1.show()  

	#rm.runCommand("Set Color", "yellow")
	rm.runCommand("Deselect")
	
	table.show("Results of Analysis")

	saveDir = currentDir.replace(srcDir, dstDir) if keepDirectories else dstDir
	if not os.path.exists(saveDir):
		os.makedirs(saveDir)
	IJ.log("Saving to" + saveDir)
	table.save(os.path.join(saveDir, fileName + "_Results.csv"))
	peaksTable.save(os.path.join(saveDir, fileName + "_Peaks.csv"))
	IJ.selectWindow("Log")
	IJ.saveAs("Text", os.path.join(saveDir, "Peaks_Log.txt"));

	# save ROIs
	# note that a single roi cannot be saved as zip; must be .roi
	# baseName = os.path.splitext(fileName)[0]
	
	if numRois == 1:
		rm.save(os.path.join(saveDir, baseName + "_rois.roi"))
	elif numRois > 1:	
		rm.save(os.path.join(saveDir, baseName + "_rois.zip"))
	else:
		IJ.log("No aggregates found in " + baseName)

def run():
	srcDir = srcFile.getAbsolutePath()
	dstDir = dstFile.getAbsolutePath()
	roiDir = roiFile.getAbsolutePath()
	
	#Channel_1, Channel_2, radius_background, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist = getOptions()
	ch1Name, ch2Name, Channel_1, Channel_2, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist = getOptions()
	
	IJ.log("\\Clear")
	IJ.log("Processing batch Find_close_peaks")
	IJ.log("options used:" \
	+ "\n" + "channel 1:" + ch1Name + ", " + str(Channel_1) \
		+ "\n" + "channel 2:"+ ch2Name+ ", "+ str(Channel_2) \
		+ "\n" + "Smaller Sigma in um:"+ str(sigmaSmaller) \
		+ "\n" + "Larger Sigma in um:"+str(sigmaLarger) \
		+ "\n" + "Min Peak Value for channel 1:"+str(minPeakValueCh1) \
		+ "\n" + "Min Peak Value for channel 2:"+str(minPeakValueCh2) \
		+ "\n" + "Min dist between peaks in pixels:"+str(min_dist))

	for root, directories, filenames in os.walk(srcDir):
		filenames.sort();
	for filename in filenames:
		# skip dotfiles
		if filename.startswith("."): 
			continue
		# Check for file extension
		if not filename.endswith(ext):
			continue
		# Check for file name pattern
		if containString not in filename:
			continue
		#process(srcDir, dstDir, root, filename, keepDirectories, Channel_1, Channel_2, radius_background, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist)
		process(srcDir, roiDir, dstDir, root, filename, keepDirectories, ch1Name, ch2Name, Channel_1, Channel_2, sigmaSmaller, sigmaLarger, minPeakValueCh1, minPeakValueCh2, min_dist)
		
	# clean up
	rm = RoiManager.getInstance()
	if not rm:
		rm = RoiManager()
	rm.reset()
	
	IJ.run("Close All", "")
	IJ.log("Done!")

run()

